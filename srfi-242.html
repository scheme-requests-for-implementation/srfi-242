<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>SRFI 242: The CFG Language</title>
    <link href="/favicon.png" rel="icon" sizes="192x192" type="image/png">
    <link rel="stylesheet" href="https://srfi.schemers.org/srfi.css" type="text/css">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
      body
      {
	  counter-reset: section;
	  font-family: serif;
      }
      h2
      {
	  counter-reset: subsection;
      }
      h2:not(#issues)::before
      {
	  counter-increment: section;
	  content: counter(section) " ";
      }
      h3
      {
	  counter-reset: subsubsection;
      }
      h3::before
      {
	  counter-increment: subsection;
	  content: counter(section) "." counter(subsection) " ";
      }
      h4::before
      {
	  counter-increment: subsubsection;
	  content: counter(section) "." counter(subsection) "." counter(subsubsection) " ";
      }
      span.token
      {
          font-family: serif;
      }
      span.token::before
      {
          content: "⟨";
      }
      span.token::after
      {
          content: "⟩";
      }
      dl.entries dt
      {
	  background-color: lightgrey;
      }
      dl.entries dd
      {
	  margin-left: 0;
      }
      dl.entries > dt.condition-type::after
      {
	  float: right;
	  content: "condition type"
      }
      dl.entries > dt.procedure::after
      {
	  float: right;
	  content: "procedure"
      }
      dl.entries > dt.syntax::after
      {
	  float: right;
	  content: "syntax"
      }
      dl.entries > dt.cfg::after
      {
	  float: right;
	  content: "cfg syntax"
      }
      dt.entry > span.type
      {
	  float: right;
      }
      pre, code
      {
	  font-size: smaller;
      }
      pre.example
      {
	  margin-left: 1em;
	  margin-right: 1em;
      }
      pre.example > span.result
      {
	  float: right;
      }
      pre.example > span.result::before
      {
	  padding-left: 1em;
	  padding-right: 1em;
	  content: "⟹"
      }
      sup
      {
	  display: inline-block;
      }
    </style></head>
  <body>
    <h1><a href="https://srfi.schemers.org/"><img class="srfi-logo" src="https://srfi.schemers.org/srfi-logo.svg" alt="SRFI surfboard logo" /></a>242: The CFG Language</h1>

    <p>by Marc Nieper-Wißkirchen</p>

    <h2 id="status">Status</h2>

    <p>This SRFI is currently in <em>draft</em> status.  Here is <a href="https://srfi.schemers.org/srfi-process.html">an explanation</a> of each status that a SRFI can hold.  To provide input on this SRFI, please send email to <code><a href="mailto:srfi+minus+242+at+srfi+dotschemers+dot+org">srfi-242@<span class="antispam">nospam</span>srfi.schemers.org</a></code>.  To subscribe to the list, follow <a href="https://srfi.schemers.org/srfi-list-subscribe.html">these instructions</a>.  You can access previous messages via the mailing list <a href="https://srfi-email.schemers.org/srfi-242/">archive</a>.</p>
    <ul>
      <li>Received: 2022-11-10</li>
      <li>60-day deadline: 2023-01-14</li>
      <li>Draft #1 published: 2022-11-15</li>
      <li>Draft #2 published: 2023-10-12</li>
      <li>Marc Nieper-Wißkirchen's <a href="https://github.com/mnieper/srfi-242">personal
	Git repo for this SRFI</a> for reference while the SRFI is in
	<em>draft</em> status (<a href="https://htmlpreview.github.io/?https://github.com/mnieper/srfi-242/blob/master/srfi-242.html">preview</a>)</li>
    </ul>

    <h2 id="abstract">Abstract</h2>


    <p>This SRFI defines a language to describe control-flow graphs
      (CFGs) suitable for formulating iterative and recursive
      algorithms.  Using the notion of a CFG term, this language can
      be seamlessly embedded in the Scheme language.  Complex CFG
      terms can be composed from simple CFG terms.</p>

    <h2 id="issues">Issues</h2>

    <p>There are none at present.</p>

    <h2 id="rationale">Rationale</h2>

    <p>In the Scheme language, procedures (and thus jump labels,
      according to lambda-the-ultimate philosophy) are first-class
      entities.  In a certain sense, this makes the control-flow graph
      of a Scheme program a dynamic and not static entity.</p>

    <p>The CFG language described in this SRFI, on the other hand,
      describes a static control-flow graph.  For the applications
      where this is sufficient, this has the advantage that the
      control-flow graph can be readily statically reasoned about,
      allowing one, in particular, to define variable scope in terms of
      it.</p>

    <p>The CFG language itself is useful for describing iterative and
      recursive algorithms more clearly than it is possible in the
      Scheme language through tail calls and (multiple) return values.
      Its <em>raison d'être</em>, however, is that more specialized languages
      like that of a loop facility can be easily built on top of
      it.</p>

    <p>The origin of the CFG language described in this SRFI is Olin
      Shiver's paper <i>The Anatomy of a Loop: A story of scope and
        control</i>.  In his paper, he makes two important
      points: The main iterative control construct in Scheme is a tail
      call.  While a tail call as a <q>goto that passes arguments</q>
      is a pretty powerful construct, it is also as low-level as a
      goto.  His first point is that this implies that it is not the
      right tool to write down iterative algorithms in a high-level
      fashion.  This fact has stimulated the search for loop
      facilities allowing one to express iterative algorithms more
      abstractly and more composably.  His second point is that just as
      the scoping of variables is well-defined in the Scheme
      language, a well-defined model of (loop) variable scoping is
      needed for loop facilities as well.  For this, he formulates a
      new scoping rule, namely that binders dominate references.</p>

    <p>While not all surface syntax has been adopted from Olin
      Shiver's paper, the core of the language described here subsumes
      his conception.  The addition of a facility to handle not only
      iterative but also recursive algorithms is a new invention in
      this SRFI.  This addresses a third perceived shortcoming of the
      Scheme language.  Recursive algorithms in Scheme are based on
      the fact that Scheme procedures return values, possibly multiple ones.
      However, as soon as more than one value needs to be returned and
      each recursion step only needs to modify one of them, a
      position-only identification of return values becomes unclear
      and leads to repetition of code.  Instead, the CFG language in
      this SRFI gives names to intermediate results and allows
      parallel processing of them.</p>

    <p>Thanks to Scheme's expressive macro system, the CFG language
      can be seamlessly implemented in the standard Scheme language,
      fully respecting Scheme semantics.</p>

    <p>The author plans to submit a SRFI describing an extensible loop
      facility built on the CFG language defined in this SRFI in the
      future.</p>

    <h3>Examples</h3>

    <p>The following expression evaluates to an (iterative) procedure that takes a
      list of integers and returns two values, the number of even and
      the number of odd values in the list.</p>

    <pre class=example>(lambda (n*)
  (cfg
      (labels [(f (execute
                    (lambda (next done)
                      (if (null? n*)
                          (done)
                          (next (car n*) (cdr n*))))
                    [(n n*)
                     (execute
                       (lambda (even odd)
                         (if (odd? n)
                             (odd (+ o 1))
                             (even (+ e 1))))
                       [(e) (call f)]
                       [(o) (call f)])]
                    [()
                     (finally (e o) (values e o) (halt))]))]
        (execute (lambda (start) (start n* 0 0)) [(n* e o) (call f)]))
    (values e o)))</pre>

    <p>The following expression evaluates to a (recursive) procedure that takes a
      list of integers and returns two values, the sublist of even
      values and the sublist of odd values.</p>

    <pre class=example>(lambda (n*)
  (cfg
      (labels [(f (execute
                    (lambda (next done)
                      (if (null? n*)
                          (done)
                          (next (car n*) (cdr n*))))
                    [(n n*)
                     (execute
                       (lambda (even odd)
                         (if (odd? n)
                             (odd)
                             (even)))
                       [()
                        (finally (e*) (cons n e*) (call f))]
                       [()
                        (finally (o*) (cons n o*) (call f))])]
                    [()
                     (finally (e* o*) (values '() '()) (halt))]))]
        (execute (lambda (start) (start n*)) [(n*) (call f)]))
    (values e* o*)))</pre>

    <h3>Using the <code>cfg</code> form</h3>

    <p>A <code>cfg</code> expression lets control flow along the edges
      of a control-flow graph (CFG) defined by the <code>cfg</code>
      expression, potentially binding so-called loop variables, until
      a <code>halt</code> CFG block is reached.  Then, control flows
      backwards along the edges previously taken, potentially binding
      so-called return variables.  Finally a Scheme expression is
      evaluated in an environment extended by these bindings, and its
      values are returned.</p>

    <p>The general form of a <code>cfg</code> expression is</p>

    <p><code>(cfg <span class=token>cfg
	  term</span> <span class=token>result expression</span>)</code></p>

    <p>where the <code><span class=token>cfg term</span></code> describes
      the CFG and <code><span class=token>result
	  expression</span></code> is an arbitrary Scheme expression.</p>

    <p>The simplest CFG is just one consisting of a <code>halt</code>
      CFG block, whose syntax simply is:</p>

    <p><code>(halt)</code></p>

    <p>For example, we have</p>

    <pre class=example>(cfg (halt) (+ 1 2))<span class=result>3</span></pre>

    <p>as the control flow along this CFG, which has no edges,
      immediately stops, leading on to the evaluation of the return expression.</p>

    <p>A <code>finally</code> CFG block is used to bind return
      variables.  The general syntax of a <code>finally</code> block
      is:</p>

    <p><code>(finally <span class=token>formals</span> <span class=token>expression</span> <span class=token>cfg
    term</span>)</code></p>

    <p>When control enters the CFG fragment it describes, control is
      passed to the CFG fragment described by
      the <code><span class=token>cfg term</span></code> first.  When
      control finally flows backwards, the
      (Scheme) <code><span class=token>expression</span></code> is
      evaluated to yield values that are bound as return variables to
      the <code><span class=token>formals</span></code>.  For example,
      we have:</p>

    <pre class=example>(cfg
    (finally (x . y) (values 1 2 3)
      (halt))
  (list x y)<span class=result>(1 (2 3))</span></pre>

    <p>A more complicated example is the following:</p>

    <pre class=example>(let ([x 1])
  (cfg
      (finally (y) (+ x 2)
        (finally (x) (+ x 1)
          (halt)))
    (list x y)))<span class=result>(2 4)</span></pre>

    <p>Here, control flows first from top to bottom and then
      backwards.  The <code>finally</code> CFG blocks bind the return
      variables during the backward flow.  The expression <code>(+ x
      1)</code> sees no binding of a return variable, only the outer
      binding of <code>x</code>.  On the other hand, the
      expression <code>(+ x 2)</code> sees the binding
      of <code>x</code> as a return variable by the
      inner <code>finally</code> CFG block.</p>

    <p>While <code>finally</code> CFG blocks are used to perform
      actions during the backward control flow, <code>execute</code>
      CFG blocks perform actions during the initial forward flow
      through the CFG.  The syntax of an <code>execute</code> CFG block is given by</p>

    <p><code>(execute <span class=token>procedure expression</span> [<span class=token>formals</span> <span class=token>cfg term</span>] &hellip;)</code></p>

    <p>where <code><span class=token>procedure
      expression</span></code> is a Scheme expression that must
      evaluate to a procedure accepting as many arguments as there
      are <code><span class=token>cfg term</span></code>s in
      the <code>execute</code> CFG term.  When the forward control
      flow through the CFG reaches an <code>execute</code> CFG block,
      this procedure is called and should tail-call one of its
      arguments.  Control flow then proceeds with the CFG block
      described by the corresponding <code><span class=token>cfg
	  term</span></code>:</p>

    <pre class=example>(let ([x 1] [y 2])
  (cfg
      (finally (y) (+ x 3)
        (execute
            (lambda (e)
              (set! x y)
              (e))
          [() (halt)]))
    (list x y)))<span class=result>(2 5)</span></pre>

    <p>In this example, the forward control flow passes through
      the <code>finally</code> CFG block before it reaches
      the <code>execute</code> block.  The procedure expression is
      evaluated in the environment where <code>x</code> is bound
      to <code>1</code> and <code>y</code> is bound to <code>2</code>.
      The tail call to <code>e</code> lets the control flow continue
      with the <code>halt</code> CFG block, from where it flows
      backward.  The backward control flow passes through
      the <code>execute</code> CFG block before the <code>(+ x
      3)</code> is evaluated and the return variable <code>y</code> is
      bound to the result <code>6</code>.</p>

    <p><code>Execute</code> CFG terms are used to create CFGs with
      branches.  For this, more than one <code><span class=token>cfg
      term</span></code> has to be provided.  Consider the following example:</p>

    <pre class=example>(let ([x 1] [y 2])
  (cfg
      (execute
          (lambda (e1 e2)
            (if (odd? y) (e1) (e2)))
        [() (halt)]
        [() (finally (x) 3 (halt))])
    (+ x 10)<span class=result>11</span></pre>

    <p>Here, the control flow exiting the <code>execute</code> CFG
      block can proceed along two possible edges, <code>e1</code>
      and <code>e2</code>, depending on the parity of <code>y</code> in
      this example.  It stands out that the value of the example
      expression is not <code>13</code>, as one might have expected,
      but <code>11</code>.  In other words, the binding
      of <code>x</code> that is visible in <code>(+ x 10)</code> is
      the <code>let</code> binding of <code>x</code> and not the
      binding as a return variable introduced in
      the <code>finally</code> CFG block.  To understand this, we have
      to introduce the rule by with which the scope of return
      variables is determined.  A CFG block (and, likewise,
      the <code><span class=token>result expression</span></code>) are
      in the scope of a return variable if this CFG block
      post-dominates definitions of this return variable, that is if
      all possible control flow paths starting at the CFG block and
      ending at a <code>halt</code> CFG block pass through a
      definition of the return variable, which happens along the entry
      edge of a <code>finally</code> CFG block.  In the example above,
      this is not the case.  There is a (statically possible)
      control-flow path from the entry block to the
      first <code>halt</code> CFG block that does not pass through
      a <code>finally</code> CFG block defining the return
      variable <code>x</code>.  Compare with the following two
      examples:</p>

    <pre class=example>(let ([x 1] [y 2])
  (cfg
      (execute
          (lambda (e1 e2)
            (if (odd? y) (e1) (e2)))
        [() (finally (x) #f (halt))]
        [() (finally (x) 3 (halt))])
    (+ x 10)<span class=result>13</span></pre>

    <pre class=example>(let ([x 1] [y 2])
  (cfg
      (finally (x) 3
        (execute
            (lambda (e1 e2)
              (if (odd? y) (e1) (e2)))
          [() (halt))]
          [() (halt))]))
    (+ x 10)<span class=result>13</span></pre>

    <p>So far, we haven't talked about
      the <code><span class=token>formals</span></code> that appear in
      a <code>execute</code> CFG term.  Using these, we can bind a
      different kind of variables, namely so-called loop variables.
      One can think of loop variables as being defined during forward
      control flow and return variables as being defined during
      backward flow.  The value to which a loop variable is bound
      when control flow leaves along an edge of
      an <code>execute</code> CFG Term is passed as an argument to
      the tail-called procedure that corresponds to the edge:</p>

    <pre class=example>(let ([x 1])
  (cfg
      (execute
          (lambda (e)
            (e (+ x 2)))
        [(x) (finally (y) (+ x 3) (halt))])
    y)<span class=result>6</span></pre>

    <p>In <code>(+ x 2)</code>, the variable <code>x</code>
      is <code>let</code>-bound to <code>1</code>, and in <code>(+ x
	3)</code> the binding as a loop variable to <code>(+ 1 2)</code>
      is visible.</p>

    <p>While the scoping rule of return variables is based on the
      post-dominance relation, the scoping rule for loop variables is
      based on the dominance relation: A CFG block is in the scope of
      a loop variable if definitions of this loop variable dominate
      the CFG block, that is if all possible control flow paths
      starting at the entry of the whole CFG and ending at the CFG
      block pass through a definition of the loop variable, which
      happens along an edge exiting an <code>execute</code> CFG block.</p>

    <p>In the following example, the definitions of
      the loop variable <code>x</code> do not dominate the expression <code>(+ x 3)</code>:</p>

    <pre class=example>(let ([x 1] [y 2])
  (cfg
      (execute
          (lambda (e1 e2)
            (if (odd? y) (e1 5) (e2)))
        [(x) (finally (y) (+ x 2) (halt))]
        [() (finally (y) (+ x 3) (halt))])
    y))<span class=result>4</span></pre>

    <p>The expressions in the <code>finally</code> CFG terms are
      evaluated with loop and return variables in scope.  If a loop
      and a return variable have the same name and both are in scope,
      the return variable shadows the loop variable.  In the following
      example, <code>x</code> is bound to <code>1</code> in <code>(+ x
      1)</code>, bound to <code>2</code> in <code>(+ x 3)</code>,
      bound to <code>5</code> in <code>(+ x 2)</code> and bound
      to <code>7</code> in <code>(+ x 4)</code>:</p>

    <pre class=example>(let ([x 1])
  (cfg
      (execute
          (lambda (e)
            (e (+ x 1)))
        [(x) (finally (x) (+ x 2)
               (finally (x) (+ x 3)
                 (halt)))])
    (+ x 4)<span class=result>11</span></pre>

    <p>Another CFG term that can be used to define loop variables is
      <code>bind</code>.  Its syntax is:</p>

    <p><code>(bind
      ([<span class=token>formals</span> <span class=token>expression</span>]
      ...) <span class=token>cfg term</span>)</code></p>

    <p>When the forward control flow reaches a <code>bind</code> CFG
      term, the <code><span class=token>expression</span></code>s are
      evaluated in the same environment in which
      the <code><span class=token>procedure expression</span></code>
      of an <code>execute</code> CFG term would be evaluated.  Then,
      all formals are bound in parallel, and the loop variable bindings
      become visible in the <code><span class=token>cfg
      term</span></code>, with which the forward control flow
      proceeds.  The <code>bind</code> CFG term is similar to
      the <code>let-values</code> Scheme expression, which binds
      multiple Scheme variables in parallel.</p>

    <pre class=example>(let ([x 1] [y 2])
  (cfg
      (bind ([(x) y] [(y) x])
        (finally (x y) (values x y) (halt)))
    (list x y)))<span class=result>(2 1)</span></pre>

    <p>In order to construct more interesting examples, we need to be
      able to introduce loops in control-flow graphs.  This is
      possible with the use of <code>labels</code> CFG terms, which have
      the following syntax:</p>

    <p><code>(labels
    ([<span class=token>label</span> <span class=token>cfg
    term</span>] &hellip;) <span class=token>body cfg
    term</span>)</code></p>

    <p>where each <code><span class=token>label</span></code> is an
      identifier.  A <code>labels</code> CFG term binds
      the <code><span class=token>labels</span></code> to
      the <code><span class=token>cfg term</span></code>s, and this
      binding is visible within the <code><span class=token>cfg
      term</span></code>s and the <code><span class=token>body cfg
      term</span></code>, much like the semantics of
      the <code>letrec</code> expression for Scheme code.  When
      (forward) control flow enters a <code>labels</code> CFG
      fragment, the control flow is passed to the CFG block described
      by the <code><span class=token>body cfg term</span></code>.</p>

    <p>Control can flow to the CFG block described by
      a <code><span class=token>cfg term</span></code>
      using <code>call</code> CFG terms with the corresponding label.
      The syntax of a <code>call</code> CFG term is:</p>

    <p><code>(call <span class=token>label</span>)</code></p>

    <p>Labels occupy a different namespace than variables (of any kind) or keywords.  Labels are lexically scoped.</p>

    <pre class=example>(let ([x 1])
  (cfg
      (labels ([x (finally (x) x (halt))])
        (call x))
    x))<span class=result>1</span></pre>

    <p>In the following example (from Olin Shiver's paper),
    the <code>finally</code> CFG block is dominated by definitions of
    the loop variable <code>y</code>.  When the control flows through
    the label <code>la</code>, the loop variable <code>y</code> is
    bound before the call to <code>la</code>; otherwise, when the
    control flows through the label <code>lb</code>, the loop
      variable <code>y</code> is bound before the call
      to <code>lj</code>:</p>

    <pre class=example>(let ([x 1]
      [f (lambda (y) (set! x y))]
      [g (lambda (y) (set! x (- y 1)))])
  (cfg
      (labels ([lj (finally y (+ y 10) (halt))]
               [la (execute (lambda (e1)
                              (f y) (e1))
                     [() (call lj)])]
               [lb (execute (lambda (e1)
                              (g x) (e1 (* x x)))
                     [(y) (call lj)])])
        (execute (lambda (e1 e2)
                   (if (odd? x)
                       (e1 (+ x 1))
                       (e2)))
          [(y) (call la)]
          [() (call lb)]))
    (list x y)))<span class="result">(2 12)</span></pre>

    <p><code>Label*</code> is another binding construct for CFG
    labels; it is related to <code>labels</code> as <code>let*</code>
    is related to <code>letrec</code>.  In particular, the binding of
    a label by <code>label*</code> is not visible within the CFG term
    bound by the label.  The syntax of <code>label*</code> does
    not differ from the <code>labels</code> syntax:</p>

    <p><code>(label*
    ([<span class=token>label</span> <span class=token>cfg
    term</span>] &hellip;) <span class=token>body cfg
    term</span>)</code></p>

    <p>The semantics of <code>label*</code> can be explained through
      the following rule: Replace all occurrences
      of <code>(call <span class=token>label</span>)</code>
      in <code><span class=token>body cfg term</span></code>
      by <code><span class=token>cfg term</span></code> when the
      binding of the
      corresponding <code><span class=token>label</span></code> is not
      (lexically) shadowed by another label binding.</p>

    <pre class=example>(cfg
    (label* ([l (finally (x) 42 (halt))]
             [l (call l)])
      (call l))
  x)<span class=result>42</span></pre>

    <p>The final CFG term that needs to be discussed is <code>permute</code>.  Its general syntax is:</p>

    <p><code>(permute
    ([<span class="token">label</span> <span class=token>cfg
    term</span>] &hellip;) <span class=token>body cfg
    term</span>)</code></p>

    <p>When the forward control flow enters a CFG block described by
      a <code>permute</code> CFG term, the CFG blocks described by
      the <code><span class=token>cfg terms</span></code> together
      with their <code><span class=token>labels</span></code> are
      dynamically permuted, and control then passes to the the first CFG block.
      Within the lexical scope of this CFG term,
      the corresponding <code><span class=token>label</span></code> is
      bound so that when it is called, control proceeds to the
      then second <code><span class=token>cfg term</span></code> and so on
      until the then final <code><span class=token>cfg term</span></code>
      is reached whose accompanying label is bound so that when called,
      control finally proceeds to the <code><span class=token>body cfg
      term</span></code> term.</p>

    <pre class=example>(cfg
    (permute ([p (bind ([(x) 10])
                   (call p))]
              [p (bind ([(y) 20])
                   (call p))])
      (finally (z) (list x y) (halt)))
  z)<span class=result>(10 20)</span></pre>

    <p>So far, the <code>permute</code> CFG term just looks like an
      inside-out <code>label*</code> form up to the permutation that
      is involved.  The <code>permute</code> CFG term's purpose comes
      from some non-determinism it introduces.  In the above example,
      the sequencing of the two <code>bind</code> CFG terms is not
      determined, i.e. whether the forward control flow first passes
      through the lexically first <code>bind</code> CFG term and then
      through the lexically second, or vice versa.  In the above
      example, it does not matter.  In general, the non-determinism
      shows up through the binding of loop and return variables.  The
      definition of <code>x</code> by the first <code>bind</code> CFG
      term does not dominate the second <code>bind</code> CFG term
      (more precisely, the CFG block it describes), because a possible
      control flow (coming from a different sequencing) coming from
      the entry passes the second CFG block before the first.  This is
      demonstrated in the following two examples:</p>

    <pre class=example>(let ([x 1])
  (cfg
      (permute ([p (bind ([(x) 2])
                     (call p))]
                [p (bind ([(y) x])
                     (call p))])
        (finally (z) (list x y) (halt)))
    z))<span class=result>(2 1)</span></pre>

    <pre class=example>(let ([x 1])
  (cfg
      (permute ([p (finally ([y] x)
                     (call p))]
                [p (finally ([x] 2)
                     (call p))])
        (halt))
    (list x y)))<span class=result>(2 1)</span></pre>

    <p>The permutation property of the <code>permute</code> CFG terms
      also propagates to the bodies of <code>label*</code>
      and <code>labels</code> forms and through calls to labels bound
      by <code>label*</code>:</p>

    <pre class=example>(let ([x 1] [y 10])
  (cfg
      (permute ([p (bind ([(x) 2])
                     (call p))])
        (labels ()
          (label* ([p (permute ([p (bind ([(z) (list x y)])
                                     (call p))])
                        (finally (x y z) (values x y z) (halt)))])
            (permute ([p (bind ([(y) x])
                           (call p))])
              (call p)))))
    (list x y z)))<span class=result>(2 1 (1 10))</span></pre>

    <p>The final concept we need to explain are macros for
      the <code>cfg</code> form.  Like <code>define-syntax</code> is
      used to define Scheme macros, we use
      the <code>define-cfg-syntax</code> definition here, which is an ordinary Scheme definition and of the following form:</p>

    <p><code>(define-cfg-syntax <span class="token">cfg keyword</span> <span class="token">transformer expression</span>)</code></p>

    <p>(There is also a starred
      version <code>define-cfg-syntax*</code> with the same syntax,
      which does not change a previous binding of the
      identifier <code><span class=token>cfg keyword</span></code>,
      but only adds CFG keyword semantics.)</p>

    <p>When the expander processes a <code>cfg</code> form, it expands
      CFG macro uses, which look like Scheme macro uses except
      that a <code><span class=token>cfg keyword</span></code> is used
      instead of a
      (Scheme) <code><span class=token>keyword</span></code>.  CFG
      macros are expanded by the usual Scheme macro
      expansion algorithm.  An example is worth a thousand words:</p>

    <pre class=example>(define-cfg-syntax loop
  (lambda (stx)
    (syntax-case stx ()
      [(_ n-expr lp-lbl loop-cfg-term body-cfg-term)
       (identifier? #&apos;lp-lbl)
       #&apos;(bind ([(n) n-expr])
           (labels ([lp-lbl
                     (execute
                         (lambda (loop done)
                           (if (zero? n)
                               (done)
                               (loop (- n 1))))
                       [(n) loop-cfg-term]
                       [() body-cfg-term])])
             (call lp-lbl)))])))

  (cfg
      (bind ([(n) 0])
        (loop 10 next
            (bind ([(n) (+ n 2)])
              (call next))
          (finally (n) n (halt))))
    n)<span class=result>20</span></pre>

    <p>The example above also demonstrates the usual hygiene
      provisions of (Scheme) macros; the variable <code>n</code>
      introduced in the macro is effectively renamed so that it
      doesn't shadow the variable <code>n</code> in the macro use.
      This hygiene is also the reason why the label <code>next</code>
      has to be given as an argument to the macro.  One can actually
      get rid of this as the following example shows:</p>

    <pre class=example>(define-cfg-label next)
(define-cfg-syntax loop
  (lambda (stx)
    (syntax-case stx ()
      [(_ n-expr loop-cfg-term body-cfg-term)
       #&apos;(bind ([(n) n-expr])
           (labels ([next
                     (execute
                         (lambda (loop done)
                           (if (zero? n)
                               (done)
                               (loop (- n 1))))
                       [(n) loop-cfg-term]
                       [() body-cfg-term])])
             (call next)))])))

  (cfg
      (bind ([(n) 0])
        (loop 10
            (bind ([(n) (+ n 2)])
              (call next))
          (finally (n) n (halt))))
    n)<span class=result>20</span></pre>

    <p>Here, we used the <code>define-cfg-label</code> definition, whose syntax is simply:</p>

    <p><code>(define-cfg-label <span class=token>label</span>)</code></p>

    <p>(The <code>define-cfg-label</code> syntax also comes in a
      starred version <code>define-cfg-label*</code>.)  This definition
      binds <code><span class=token>label</span></code> to a fresh label
      and <code><span class=token>label</span></code> is replaced by
      this label in <code>labels</code>, <code>label*</code>,
      and <code>call</code> CFG terms
      where <code><span class=token>label</span></code> is in scope.</p>

    <h2 id="specification">Specification</h2>

    <p>The identifiers defined in this section are exported by
      the <code>(srfi :242 cfg)</code> and the <code>(srfi :242)</code>
      libraries in case of an R<sup>6</sup>RS system and by
      the <code>(srfi 242)</code> library in case of an R<sup>7</sup>RS
      system.</p>

    <p><i>Remark:</i> This section is a formal account of the syntax
      and semantics of the <code>cfg</code> form.  It should not be
      misunderstood as a gentle introduction, which was given in the
      previous section.</p>

    <h3>CFGs</h3>

    <p>The following definitions are standard, but are included here
      for the sake of completeness.</p>

    <p>A <dfn>control-flow graph (CFG)</dfn> is a (finite) set
      of <dfn>CFG blocks</dfn> together with a <dfn>predecessor</dfn>
      relation such that there is exactly one CFG block with no
      predecessor.  This CFG block is the <dfn>entry block</dfn> of
      the cfg.  A CFG block that is not the predecessor of any other
      block is an <dfn>exit block</dfn>.  A CFG block is
      a <dfn>successor</dfn> of another one if the latter is a
      predecessor of the former.  (In what follows, we usually
      describe CFGs by defining the successors of each block, which
      amounts to the same thing: the predecessor relation is basically
      the inverse one.)</p>

    <p>The <dfn>dominance</dfn> relation of a CFG is the largest
      relation on the set of its CFG blocks such that the following
      holds: The set of strict dominators of the entry block is empty.
      The set of strict dominators of any other block is a subset of
      the set of dominators of each predecessor of the block.  Here,
      a <dfn>strict dominator</dfn> of a block is a dominator that is
      not the block itself.</p>

    <p><i>Note:</i> From the definition it follows that each block dominates
      (but not strictly dominates) itself.</p>

    <p><i>Remark:</i> Because of the condition on the entry block, the
    dominance relation is not trivial and not the maximal relation on
    the set of CFG blocks.</p>

    <p>The <dfn>post-dominance</dfn> relation of a CFG is the largest
      relation on the set of its CFG blocks such that the following
      holds: The set of strict post-dominators of an exit block is
      empty.  The set of strict post-dominators of any other block is
      a subset of the set of post-dominators of each successor of the
      block.  Here, a <dfn>strict post-dominator</dfn> of a block is a
      post-dominator that is not the block itself.</p>

    <h3>Preliminary notions</h3>

    <p>In order to describe the computation model of the CFG language,
      which is not the same computation model underlying Scheme (but
      can be expressed in the latter as the portable implementation
      shows), a couple of primitive notions have to be introduced,
      that is the grammatical context in which they are used.  Their
      semantic meaning only follows from the context in which they
      are used below.</p>

    <p><dfn>Loop variables</dfn> are <dfn>defined</dfn> in CFG
      blocks.  A loop variable's <dfn>scope</dfn> is the set of CFG
      blocks that are dominated by a CFG block in which the loop
      variable is defined.</p>

    <p><dfn>Return variables</dfn> are also <dfn>defined</dfn> in CFG
      blocks.  A return variable's <dfn>scope</dfn> is the set of CFG
      blocks that strictly post-dominate a CFG block in which the
      return variable is introduced.</p>

    <p>The formal description of the various CFG terms uses the notion
    of <dfn>CFG locations</dfn>, which is similarly to a location in
    the Scheme semantics, except that it can hold a CFG block instead
      of a Scheme value.</p>

    <p>Moreover, a <dfn>pending set</dfn> in the sense of the formal
      semantics below is a set of pairs, each consisting of a CFG
      location and a CFG block.</p>

    <p>The following action can be done with pending sets: when a
      pending set is <dfn>materialized</dfn> with a CFG block as
      its <dfn>tail</dfn>, the pairs of CFG locations and CFG blocks
      of the pending set are ordered non-deterministically.  In the
      CFG location of each pair, the CFG block of the following pair
      is then stored.  In the CFG location of the last pair, the tail
      CFG block is stored.  For each CFG block in the list of pairs,
      its set of successors is the one-element set containing the CFG
      block of the following pair.  For the CFG block in the last
      pair, its set of successors is the one-element set consisting of
      the tail CFG block.  The CFG block in the first pair is then
      returned as the result of the materialization.</p>

    <p>A <dfn>CFG state</dfn> is a (finite) set of bindings from
      identifiers to values.</p>

    <p>A <dfn>CFG term</dfn> is a syntactic construct in the CFG
      language that can be <dfn>evaluated</dfn> <dfn>in</dfn> an
      environment and <dfn>within</dfn> a pending set.  The result of
      the evaluation is a CFG.  A block in this CFG can
      be <dfn>called</dfn> with a CFG state.  The result of this call
      is again a CFG state.  Evaluation of CFG terms happens during
      expand-time, the calling of CFG terms during runtime.</p>

    <h3>Entry format</h3>

    <p>Each entry is of one of two categories, &ldquo;syntax&rdquo; or
      &ldquo;cfg syntax&rdquo;.  The first category is as in
      R<sup>6</sup>RS and R<sup>7</sup>RS, while an entry of the second
      category describes a syntactic construct in the CFG language.</p>

    <h3>CFG Expressions</h3>

    <dl class=entries>

      <!-- cfg -->
      <dt class=syntax><code>(cfg <span class="token">cfg term</span> <span class="token">result expression</span>)</code></dt>
      <dd>
	<p><i>Syntax:</i> <code><span class=token>Cfg
	term</span></code> is an arbitrary CFG
	term.  <code><span class=token>Result expression</span></code>
	is an arbitrary Scheme expression.</p>

	<p><i>Semantics:</i> A <code>cfg</code> expression is
	  evaluated by first evaluating
	  the <code><span class="token">cfg term</span></code> within
	  an empty pending list, resulting in a CFG.  Its entry block
	  is then called with an empty CFG state, yielding a resulting
	  CFG state.  The environment of the
	  <code>cfg</code> expression is then extended by binding the
	  return variables in whose scope
	  the <code><span class=token>result expression</span></code>
	  is to locations holding the values to which they are bound
	  in the resulting CFG state.  Finally,
	  the <code><span class=token>result expression</span></code>
	  is evaluated in this extended environment and its values
	  returned as the results of the <code>cfg</code>
	  expression.</p>
      </dd>
    </dl>

    <p>The simplest <code>cfg</code> expression just halts and returns
    some value(s).  (The <code>halt</code> and the other cfg terms are
    described in the next subsection.)  For example:</p>

    <pre class=example>(cfg (halt) 'done)<span class=result>done</span></pre>

    <p>Using a <code>finally</code> cfg term, return variables can be
    bound that can be used in the <code><span class=token>result
	  expression</span></code>:</p>

    <pre class=example>(let ([x 1])
  (cfg (finally (x y) (values (+ x 1) (+ x 2))
         (halt))
    (list x y)))<span class=result>(2 3)</span></pre>

    <p>Loop variables are bound through <code>execute</code> terms:</p>

    <pre class=example>(let ([x 1])
  (cfg (execute (lambda (e)
                  (e (+ x 1)))
         [(x) (finally (res) x (halt))])
    res))<span class=result>2</span></pre>

    <p><code>Execute</code> CFG terms can have more than one successor.
      During evaluation, one control path is chosen:</p>

    <pre class=example>(let ([x 1])
  (cfg (execute (lambda (e1 e2)
                  (if (even? x) (e1) (e2 &apos;odd)))
         [() (finally (res) 'even (halt))]
         [(a) (finally (res) a (halt))])
    res))<span class=result>odd</span></pre>

    <p>Due to loop variable scoping, the second <code>finally</code>
    cannot simply be hoisted because it would no longer be dominated
    by the introduction of the loop
    variable <code><var>a</var></code>:</p>

    <pre class=example>(let ([a &apos;outer]
      [x 1])
  (cfg (finally (res) a
         (execute (lambda (e1 e2)
                    (if (even? x) (e1) (e2 &apos;odd)))
           [() (finally (res) 'even (halt))]
           [(a) (halt)]))
      res))<span class=result>outer</span></pre>

    <p>And due to return-variable scoping, the
    first <code>finally</code> cannot simply be left out because the
    entry block would no longer post-dominate an introduction of
      the <code><var>res</var></code> return variable:</p>

    <pre class=example>(let ([res &apos;outer]
      [x 1])
   (cfg (execute (lambda (e1 e2)
                   (if (even? x) (e1) (e2 &apos;odd)))
          [() (halt)]
          [(a) (finally (res) a (halt))])
      res))<span class=result>outer</span></pre>

    <p>Loop variables are called loop variables because the main
      reason for the CFG language is that it allows writing loops.
      This can be done with <code>labels</code> CFG terms.  Here, we
      also use the <code>bind</code> CFG term to bind loop
      variables easily:</p>

    <pre class="example">(cfg (labels ([f (execute
                     (lambda (e1 e2)
                       (if (> x 6)
                           (e1)
                           (e2 (+ x 1) (* a x))))
                   [() (finally (res) a (halt))]
                   [(x a) (call f)])])
       (bind ([(x) 1] [(a) 1]) (call f)))
  res)<span class=result>720</span></pre>

    <p>Finally, <code>permute</code> CFG terms can be used to create
      sequences of CFG blocks so that loop variables and return
      variables introduced in these blocks do not have the other
      blocks of this sequence in scope (comparable to scoping rules of
      the <code>let</code> expression of Scheme):</p>

    <pre class="example">
(let ([x &apos;outer] [y &apos;outer])
  (cfg (label* ([c (permute ([p (finally (y) &apos;inner
                                  (bind ([(a) x]) (call p)))])
                     (finally (a) a (halt)))])
         (permute [(p (finally (b) y
                        (bind ([(x) &apos;inner]) (call p))))]
           (call c)))
    (list a b)))<span class=result>(outer outer)</span></pre>

    <p>(<code>Label*</code> CFG terms do not allow loops
      as <code>labels</code> CFG terms, but <code>permute</code>
      sequences carry forward across calls to labels introduced
      by <code>label*</code>.)</p>

    <h3>Primitive CFG terms</h3>

    <p>The following entries describe the primitive CFG terms.
      A <code><span class=token>label</span></code> is an identifier.
      Labels do not occupy the same namespace as keywords and all kind
      of variables.  That is, within the same scope, an identifier can
      be bound as a label and as a variable or keyword, and local
      bindings of either kind do not shadow other bindings of the
      other kind.  There are two (disjoint) types of
      labels, <code><span class=token>static labels</span></code>
      and <code><span class=token>dynamic labels</span></code>.
      Static labels are bound to CFG terms, and dynamic labels are
      bound to CFG locations.</p>

    <dl class=entries>
      <!-- execute -->
      <dt class=cfg><code>(execute <span class=token>procedure
      expression</span>
      [<span class=token>formals</span> <span class="token">cfg term</span>]
      &hellip;)</code></dt>
      <dd>
	<p>When an <code>execute</code> CFG term is evaluated in
	  an environment and within a pending set,
	  the <code><span class="token">cfg term</span></code>s
	  are evaluated to CFG blocks in no particular order in the
	  environment, each within an empty pending set.  The pending
	  set in which the <code>execute</code> CFG term is being
	  evaluated is then materialized with a new <var>CFG block</var>
	  as its tail and the materialization is returned.</p>

	<p>When the <var>CFG block</var> is later called with a CFG
	  state, the environment of the surrounding <code>cfg</code>
	  expression is extended by binding each loop variable in
	  whose scope the <code>execute</code> CFG term occurs to a fresh
	  location holding the value to which it is bound in the CFG
	  state.  The <code><span class=token>procedure
	  expression</span></code> is then evaluated in this extended
	  environment to yield a procedure value.  This procedure is
	  then tail-called with as many procedure arguments as there
	  are <code><span class="token">cfg term</span></code>s.  The
	  procedure should call one of the arguments exactly once and
	  the call should be a tail call.  In the continuation of this
	  tail call, the CFG state is then extended by binding the
	  corresponding <code><span class=token>formals</span></code>
	  to the return values of the call, and the CFG block
	  resulting from the evaluation of the
	  corresponding <code><span class=token>cfg term</span></code>
	  is then tail-called with the extended CFG state and the
	  resulting CFG state is returned.</p>

	<p>The <var>CFG block</var> has the CFG blocks resulting from evaluation
	  of the <code><span class=token>cfg term</span></code>s as
	  successors.</p>

	<p>The variables of each <code>formals</code> are introduced
	  as loop variables in the corresponding CFG block.</p>
      </dd>

      <!-- halt -->
      <dt class=cfg><code>(halt)</code></dt>
      <dd>
	<p>When a <code>(halt)</code> CFG term is evaluated, the
	  pending set is materialized with a new <var>CFG block</var> as
	  its tail, and the materialization is returned.</p>

	<p>When the <var>CFG block</var> is called with a CFG state,
	  it simply returns an empty CFG state.</p>

	<p>The <var>CFG block</var> has no successors.</p>
      </dd>

      <!-- labels -->
      <dt class=cfg><code>(labels
      ([<span class="token">dynamic label</span> <span class=token>cfg term</span>]
      &hellip;) <span class=token>body cfg term</span>)</code></dt>
      <dd>
        <p>When a <code>labels</code> CFG term is evaluated in an
          environment within a pending set, the environment is
          extended by binding
          each <code><span class="token">label</span></code> to a CFG
          location initially holding an invalid CFG block.
          The <code><span class=token>cfg term</span></code>s and
          the <code><span class=token>body cfg term</span></code>
          are then evaluated in an unspecified order in this extended
          environment.  In this environment,
          the <code><span class=token>cfg term</span></code>s are
          evaluated within an empty pending set and
          the <code><span class=token>body cfg term</span></code>
          is evaluated within the pending set in which
          the <code>labels</code> CFG term is being evaluated.
          For each <code><span class=token>label</span></code>, the
          CFG block resulting from evaluating the
          corresponding <code><span class=token>cfg term</span></code>
          is then stored in the corresponding CFG location.  Finally,
          the CFG block resulting from evaluation of
          the <code><span class=token>body cfg term</span></code>
          is returned.</p>

        <p>When the CFG block returned by the <code>labels</code> CFG
          term is later called with a CFG state, the CFG block resulting
          from evaluating
          the <code><span class=token>body cfg term</span></code> is
          tail-called with the CFG state and the resulting CFG state is
          returned.</p>
      </dd>

      <!-- label* -->
      <dt class=cfg><code>(label* ([<span class="token">static
      label</span> <span class=token>cfg term</span>]) <span class=token>body cfg term</span>)</code></dt>
      <dd>
        <p>When a <code>label*</code> CFG term is evaluated in an
          environment within a pending set, the environment is
          extended by binding
          the <code><span class=token>label</span></code> to the
          (unevaluated) <code><span class=token>cfg
          term</span></code>.
          The <code><span class=token>body cfg term</span></code>
          is then evaluated in this environment within the pending
          set.  The result of this evaluation is returned.</p>

        <p>When the CFG block returned by the <code>labels</code> CFG
          term is later called with a CFG state, the CFG block resulting
          from evaluating
          the <code><span class=token>body cfg term</span></code> is
          called with the CFG state, and the resulting CFG state is
          returned.</p>

	<p>It is a syntax or undefined violation if
	  evaluating <code><span class=token>cfg term</span></code>
	  in the non-extended environment within the empty pending set
	  would raise an exception of type <code>&amp;syntax</code>
	  or <code>&amp;undefined</code>, respectively.</p>

        <p><i>Note:</i> The <code>label*</code> syntax will be extended below.</p>
      </dd>

      <!-- call (static) -->
      <dt class=cfg><code>(call <span class=token>static label</span>)</code></dt>
      <dd>
        <p>When the <code>call</code> CFG term is evaluated in an
          environment and within a pending set, the CFG term to which
          the <code><span class=token>static label</span></code> is
          bound is evaluated in the same environment and within the
          same pending set, and the result of this evaluation is returned.</p>

	<p>It is an undefined violation if
	  the <code><span class=token>static label</span></code> is
	  not bound in the environment in which the <code>call</code>
	  CFG term is evaluated.</p>
      </dd>

      <!-- call (dynamic) -->
      <dt class=cfg><code>(call <span class=token>dynamic label</span>)</code></dt>
      <dd>
        <p>When the <code>call</code> CFG term is evaluated in an
          environment within a pending set, the location to which
          the <code><span class=token>dynamic label</span></code> is
          bound is looked up and remembered.  The pending set is then
          materialized with a new <var>CFG block</var> as its tail, and
          the materialization is returned.

        <p>When the CFG block returned by the <code>call</code> CFG
          term is called with a CFG state, the CFG block stored in the
          remembered location is tail-called with the CFG state, and the
          resulting CFG is returned.</p>

        <p>The <var>CFG block</var> returned by the <code>call</code> CFG term
          has the CFG block eventually stored in the remembered location
          as its successor.</p>

	<p>It is an undefined violation if
	  the <code><span class=token>dynamic label</span></code> is not bound
	  in the environment in which the <code>call</code> CFG term
	  is evaluated.</p>
      </dd>


      <!-- finally -->
      <dt class=cfg><code>(finally <span class=token>cfg formals</span> <span class=token>expression</span> <span class=token>cfg term</span>)</code></dt>
      <dd>
        <p>When a <code>finally</code> CFG term is evaluated
	  within a pending set, the pending set is materialized with a
	  new <var>CFG block</var> as its tail, and the
	  materialization is returned.</p>

        <p>When the <var>CFG block</var> is later called with a CFG
          state, the environment of the surrounding <code>cfg</code>
          expression is extended by binding each loop variable in
          whose scope the CFG block occurs to a fresh location holding
          the value to which it is bound in the CFG state.  Then, the
          CFG block resulting from evaluation of
          the <code>cfg term</code> is called.  The extended
          environment is then further extended by binding each return
          variable in whose scope the CFG block returned by
          the <code>finally</code> CFG term occurs to a fresh
          location holding the value to which it is bound in the
          returned CFG state.  Then,
          the <code><span class=token>expression</span></code> is
          evaluated in the doubly extended environment, the CFG
          state received from call the <code><span class=token>cfg
          term</span></code> is extended by binding
          the <code><span class=token>formals</span></code> to the
          values receiving from evaluating
          the <code><span class=token>expression</span></code>, and
          the extended CFG state is then returned.</p>

        <p>The <var>CFG block</var> returned by
          the <code>finally</code> CFG term has the CFG block
          resulting from the evaluation of
          the <code><span class=token>cfg term</span></code> as
          its successor.</p>
      </dd>

      <!-- permute -->
      <dt class=cfg><code>(permute <span class=token>dynamic
	    label</span> <span class=token>cfg term</span> <span class=token>body cfg term</span>)</code></dt>
      <dd>
        <p>When a <code>permute</code> CFG term is evaluated in an
          environment within a pending set, the environment is
          extended by binding the <code><span class=token>dynamic
          label</span></code> to a fresh CFG location initially
          holding an invalid CFG block.
          The <code><span class=token>cfg term</span></code> is
          then evaluated in this extended environment within an empty
          pending set to a CFG block.  The pending set within which
          the <code>permute</code> CFG term is being evaluated is
          then extended by adjoining a pair consisting of the fresh
          location and the resulting CFG block.  Finally,
          the <code><span class=token>body cfg term</span></code>
          is evaluated in the original environment but within the
          extended pending list, and the resulting CFG block is
          returned.</p>

        <p><i>Note:</i> The <code>permute</code> syntax will be extended below.</p>
      </dd>
    </dl>

    <h3>Tail contexts</h3>

    <p>If a <code>cfg</code> expression is in tail context,
      the <code><span class=token>result expression</span></code> is in
      tail context as well.</p>

    <h3>Non-determinism</h3>

    <p>Through <code>permute</code> CFG terms, non-trivial pending
      sets are generated.  Through the non-determinism of
      materializing pending sets, the CFGs resulting from evaluating
      CFG terms are non-deterministic as well.  For such
      non-deterministic CFGs (which can be viewed as a set of CFG
      blocks together with a set of possible predecessor relations on
      these CFG blocks), the scope of loop or return variable is
      defined as the intersection of the scopes of the loop or return
      variable over all possible materializations.
    </p>

    <h3>Derived CFG terms</h3>

    <p>The following entries describe CFG terms that can be converted
      into primitive CFG terms.</p>

    <dl class=entries>

      <!-- label* -->
      <dt class=cfg><code>(label* ([<span class="token">static
      label<sub>1</sub></span> <span class=token>cfg term<sub>1</sub></span>] &hellip;) <span class=token>body cfg term</span>)</code></dt>
      <dd>
	<p>Effectively equivalent to <code><span class=token>body cfg term</span></code> when there is no <code><span class=token>static label</span></code>.  Otherwise, effectively equivalent to
	  <code>(label* ([<span class="token">static
	      label<sub>1</sub></span> <span class=token>cfg term<sub>1</sub></span>])
	    (label* ([<span class="token">static
      label<sub>2</sub></span> <span class=token>cfg term<sub>2</sub></span>] &hellip;)
	    <span class=token>body cfg term</span>))</code>.
	</p>
	<p><i>Note:</i> This cfg syntax extends the primitive <code>label*</code> syntax to more than one <code><span class=token>static label</span></code>.</p>
      </dd>

      <!-- permute -->
      <dt class=cfg><code>(permute ([<span class="token">dynamic
      label<sub>1</sub></span> <span class=token>cfg term<sub>1</sub></span>] &hellip;) <span class=token>body cfg term</span>)</code></dt>
      <dd>
	<p>Effectively equivalent to <code><span class=token>body cfg term</span></code> when there is no <code><span class=token>dynamic label</span></code>.  Otherwise, effectively equivalent to
	  <code>(permute ([<span class="token">dynamic
	      label<sub>1</sub></span> <span class=token>cfg term<sub>1</sub></span>])
	    (permute ([<span class="token">dynamic
      label<sub>2</sub></span> <span class=token>cfg term<sub>2</sub></span>] &hellip;)
	    <span class=token>body cfg term</span>))</code>.
	</p>
	<p><i>Note:</i> This cfg syntax extends the
	primitive <code>permute</code> syntax to more than
	one <code><span class=token>dynamic label</span></code>.</p>
      </dd>

      <!-- bind -->
      <dt class=cfg><code>(bind
      ([<span class=token>formals</span> <span class=token>expression</span>]
      ...) <span class=token>cfg term</span>)</code></dt>
      <dd>
	<p>When an <code>bind</code> CFG term is evaluated in an
	  environment and within a pending set,
	  the <code><span class="token">cfg term</span></code> is
	  evaluated to CFG block in the environment within an empty
	  pending set.  The pending set in which
	  the <code>execute</code> CFG term is being evaluated is
	  then materialized with a new <var>CFG block</var> as its tail,
	  and the materialization is returned.</p>

	<p>When the <var>CFG block</var> is later called with a CFG
	state, the environment of the surrounding <code>cfg</code>
	expression is extended by binding each loop variable in whose
	scope the <code>bind</code> CFG term occurs to a fresh location
	holding the value to which it is bound in the CFG state.
	The <code><span class=token>expression</span></code>s are then
	evaluated in an unspecified order in this extended environment
	to yield values for
	each <code><span class=token>expression</span></code>.  The
	CFG state is then extended by binding
	each <code><span class=token>formals</span></code> as loop
	variables to the return values of the corresponding
	evaluation, and the CFG block resulting from the evaluation
	of <code><span class=token>cfg term</span></code> is then
	  tail-called with the extended CFG state, and the resulting CFG state
	  is returned.
	</p>

	<p>It is a syntax violation if the loop variables in
	all <code><span class=token>formals</span></code> are not
	pairwise different.</p>
      </dd>
    </dl>

    <h3>CFG syntax and label definitions</h3>

    <p>The Scheme syntax described in this section
      are <code><span class=token>definitions</span></code> that may
      appear anywhere other definitions may appear.</p>

    <p>Keyword bindings established by these definitions are visible
      throughout the body in which they appear, except where shadowed
      by other bindings, and nowhere else, just like variable bindings
      established by <code>define</code>. All bindings established by
      a set of definitions are visible within the definitions
      themselves.</p>

    <!-- define-cfg-syntax -->
    <dl class=entries>
      <dt class=cfg><code>(<span class=token>cfg keyword</span> <span class=token> datum</span> &hellip;)</code></dt>
      <dt class=cfg><code>(<span class=token>cfg keyword</span> <span class=token> datum</span> &hellip; . <span class=token>datum</span>)</code></dt>
      <dt class=cfg><code><span class=token>cfg keyword</span></code></dt>
      <dd>
	<p>
	  At the start of the evaluation of a <code>cfg</code>
	  expression, these <dfn>CFG macro uses</dfn> are expanded by
	  the syntax expander into core CFG terms just as Scheme macro
	  uses are expanded into core forms.  In particular,
	  a <dfn>CFG transformer</dfn> is like a Scheme transformer.</p>
      </dd>
      <dt class=syntax><code>(define-cfg-syntax <span class="token">cfg keyword</span> <span class="token">transformer expression</span>)</code></dt>
      <dd>
	<p>Binds <code><span class=token>cfg keyword</span></code> to
	  the value <code><span class="token">transformer
	      expression</span></code>, which must evaluate, at
	  macro-expansion time, to a CFG transformer.
	</p>
      </dd>

      <!-- define-cfg-syntax* -->
      <dt class=syntax><code>(define-cfg-syntax* <span class="token">cfg keyword</span> <span class="token">transformer expression</span>)</code></dt>
      <dd>
	<p>As <code>define-cfg-syntax</code> except that <code><span class=token>cfg
	    keyword</span></code> must be bound.  <code>Define-cfg-syntax*</code>
	  does not change the meaning of <code>keyword</code> outside <code><span class=token>cfg term</span></code>s.
	</p>
      </dd>

      <!-- define-cfg-label -->
      <dt class=syntax><code>(define-cfg-label <span class="token">identifier</span>)</code></dt>
      <dd>
	<p>Binds the <code><span class=token>identifier</span></code> to a fresh <var>label</var>.</p>
	<p>Whenever
	  the <code><span class=token>identifier</span></code> appears
	  as a <code><span class=token>static label</span></code>
	  or <code><span class=token>dynamic label</span></code>, it is replaced by the <var>label</var>.
	</p>
      </dd>

      <!-- define-cfg-label* -->
      <dt class=syntax><code>(define-cfg-label* <span class="token">identifier</span>)</code></dt>
      <dd>
	<p>As <code>define-cfg-label</code> except that <code>identifier</code> must be bound.  <code>Define-cfg-label*</code>
	  does not change the meaning of <code>identifier</code> outside <code><span class=token>cfg term</span></code>s.
	</p>
      </dd>
    </dl>

    <p>The following example defines a CFG keyword that can be used like <code>bind</code> to unconditionally bind loop variables:</p>

    <pre class=example>(define-cfg-syntax simple-bind
  (lambda (stx)
    (syntax-case stx ()
      [(_ ([id init] ...) cfg)
       (for-all identifier? #'(id ...))
       #'(execute (lambda (e)
                    (e init ...))
           [(id ...) cfg])])))

(cfg (simple-bind ([x 1] [y 2])
       (finally (res) (+ x y) (halt)))
  res)<span class=result>3</span></pre>

    <p>A probably more useful CFG macro is the following one:</p>

    <pre class=example>(define-cfg-syntax return
  (lambda (stx)
    (syntax-case stx ()
      [(_ return-var ...)
       (for-all identifier? #&apos;(return-var ...))
       #&apos;(finally (return-var ...) (values return-var ...) (halt))])))

(cfg (simple-bind ([x 1]) (return x))
  x)<span class=result>1</span></pre>

    <p>The label definition feature is demonstrated in the following example:</p>

    <pre class=example>(define-syntax permuting
  (lambda (stx)
    (syntax-case stx ()
      [(_ cfg-term ... result-expr)
       #'(cfg (permute ([p cfg-term] ...)
		(finally (res) result-expr (halt)))
	   res)])))

(permuting (simple-bind ([x 99]) (call p)) x)<span class=result>99</span></pre>

    <h2 id="implementation">Implementation</h2>

    <p>The sample implementation is a portable R<sup>6</sup>RS
      implementation written from scratch
      using <a href="https://srfi.schemers.org/srfi-213/srfi-213.html">SRFI
      213</a> The sample implementation in the git repo is configured
      for Chez Scheme.</p>

    <p><a href="https://github.com/scheme-requests-for-implementation/srfi-242">Git repo for the sample implementation.</a></p>

    <h2 id="acknowledgements">Acknowledgements</h2>

    <p>This SRFI would not exist if there hadn't been Olin Shiver's
      paper <em>The Anatomy of a Loop</em>.  In fact, almost all of
      the mental effort needed for this SRFI was already provided by
      him.  This does not imply that he does or does not endorse this
      SRFI.</p>

    <p>It was Jens Axel Søgaard who reminded me of Olin Shiver's
      paper, which I had once read but then forgotten about.</p>

    <p>During the draft period, Wolfgang Corcoran-Mathe read the
      specification thoroughly and found a number of small bugs and
      inconsistencies, which could then be fixed.</p>

    <h2 id="copyright">Copyright</h2>
    <p>&copy; 2022  Marc Nieper-Wißkirchen.</p>

    <p>
      Permission is hereby granted, free of charge, to any person
      obtaining a copy of this software and associated documentation files
      (the "Software"), to deal in the Software without restriction,
      including without limitation the rights to use, copy, modify, merge,
      publish, distribute, sublicense, and/or sell copies of the Software,
      and to permit persons to whom the Software is furnished to do so,
      subject to the following conditions:</p>

    <p>
      The above copyright notice and this permission notice (including the
      next paragraph) shall be included in all copies or substantial
      portions of the Software.</p>
    <p>
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
      NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
      BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
      ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
      CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
      SOFTWARE.</p>

    <hr>
    <address>Editor: <a href="mailto:srfi-editors+at+srfi+dot+schemers+dot+org">Arthur A. Gleckler</a></address></body></html>
